** Buscar la implentacion de search_fields para las busquedas Texto  Agregar el ALL

   Complex lookups with Q objects
    Keyword argument queries -- in filter(), etc. -- are "AND"ed together. 
    If you need to execute more complex queries (for example, queries with OR statements), you can use Q objects.

    A Q object (django.db.models.Q) is an object used to encapsulate a collection of keyword arguments. 

    For example, this Q object encapsulates a single LIKE query:

    from django.db.models import Q

    #Q objects can be combined using the & and | operators. When an operator is used on two Q objects, it yields a new Q object.
    #For example, this statement yields a single Q object that represents the "OR" of two "question__startswith" queries:

    Q(question__startswith='Who') | Q(question__startswith='What')
    

self.list_filter, self.date_hierarchy, self.search_fields,
self.list_select_related, self.list_per_page, self.list_editable, self)


search_fields

** Advanced Querys
   
   PAra el manejo de los __unicode__ puede ser usando la biblio de serializacion, creando un manager y el natural_key
   https://docs.djangoproject.com/en/1.3/topics/serialization/



   model.objects[.filter().exclude() ].values('achievements__name', 'achievement__points')

   - values(*fields)         ---------------------
     Returns a ValuesQuerySet — a QuerySet subclass that returns dictionaries when used as an iterable, rather than model-instance objects.

     >>> Blog.objects.filter(name__startswith='Beatles')
     [<Blog: Beatles Blog>]

     >>> Blog.objects.values('id', 'name')
     [{'id': 1, 'name': 'Beatles Blog'}]


   - values_list(*fields)
     This is similar to values() except that instead of returning dictionaries, it returns tuples when iterated over. Each tuple contains the value from the respective field passed into the values_list() call -- so the first item is the first field, etc. For example:

     >>> Entry.objects.values_list('id', 'headline')
     [(1, u'First entry'), ...]

   - select_related( [depth=1] )  ---------------------

     Returns a QuerySet that will automatically "follow" foreign-key relationships, selecting that additional related-object data when it executes its query.
     This is a performance booster which results in (sometimes much) larger queries but means later use of foreign-key relationships won't require database queries.

     class City(models.Model):

     class Person(models.Model):
         hometown = models.ForeignKey(City)

     class Book(models.Model):
         author = models.ForeignKey(Person)

    ...then a call to Book.objects.select_related().get(id=4) will cache the related Person and the related City:

      b = Book.objects.select_related().get(id=4)
      p = b.author         # Doesn't hit the database.
      c = p.hometown       # Doesn't hit the database.

      Sometimes you only want to access specific models that are related to your root model, not all of the related models. In these cases, you can pass the related field names to select_related() and it will only follow those relations. You can even do this for models that are more than one relation away by separating the field names with double underscores, just as for filters. For example, if you have this model:
      
      class Room(models.Model):
          building = models.ForeignKey(...)

      class Group(models.Model):
          teacher = models.ForeignKey(...)
          room = models.ForeignKey(Room)
          subject = models.ForeignKey(...)

      ...and you only needed to work with the room and subject attributes, you could write this:

      g = Group.objects.select_related('room', 'subject')
      This is also valid:

      g = Group.objects.select_related('room__building', 'subject')
      ...and would also pull in the building relation.

      You can refer to any ForeignKey or OneToOneField relation in the list of fields passed to select_related.

      It's an error to use both a list of fields and the depth parameter in the same select_related() call, since they are conflicting options.


   - distinct()    -------------

     Equivalente a SQL unique/distinc

   - extra()       -------------

     Agrega Clausulas SQL

   - anotate()     -------------

     Agrega campos agregados al Query

    >>> q = Blog.objects.annotate(Count('entry'))
    # The number of entries on the first blog
    >>> q[0].entry__count
    42

    # The number of entries on the first blog, using the name provided
    >>> q = Blog.objects.annotate(number_of_entries=Count('entry'))
    >>> q[0].number_of_entries
    42

   - defer(*fields )     -------------

     No carga de inmediato los valores indicados,  para usar con campos texto o blob

   - only(*fields)
     The only() method is more or less the opposite of defer()


   - using(alias)
     This method is for controlling which database the QuerySet will be evaluated against if you are using more than one database. 
     The only argument this method takes is the alias of a database, as defined in DATABASES.


** Ver el SQL 
   songs = Song.objects.filter(...)
   songs.query.as_sql()

** AutoField

    model._meta.pk.name


** JS Conf Store
        // myStore.load();
        // Ext.apply(Ext.data.AjaxProxy.prototype.actionMethods, { read: 'POST' });
        // store.getProxy().extraParams.feed = url;
        // store.loadPage(1);                           
        
** Lista alfabetica 

AlphabeticListe = new Ext.List({
            store:store,
            tpl:tpl,
            itemSelector:"div.member",
            grouped:true,
            //indexBar:true,
            indexBar:{
                alphabet:true,
                direction:"horizontal",
                letters: ['2','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
            }
})

-------------------------------------------
http://www.sencha.com/forum/showthread.php?24648-Dual-Example-Add-a-second-tbar-to-make-GridPanel-alphabetical-search


var alphaTbarItems = new Array();
for(var i = 65; i < 91; i++) { // JS char codes from (upper) A to Z
    var myChar = String.fromCharCode(i); // get the letter from the char code
    alphaTbarItems.push({ // add this vars to the array
        text: myChar, // just the letter
        id: 'alphaTbarItem' + myChar, // this button id will contain the letter
        enableToggle: true, // only one will be pressed
        toggleGroup: 'alphaTbarItems',
        handler: function() { // when this button is pressed
            if (this.pressed) { // if it is now in a "pressed" state (toggle is enabled)
                myDataStore.load({ // reload the dataStore
                    params: { letter: this.text, } // passing the letter as parameter
                });
            } else myDataStore.load(); // if it is unpressed, reload the dataStore with full list
        }
    });
}  \


var myListGrid = new Ext.grid.GridPanel({
    border: false,
    store: myDataStore,
    columns: [
        {header: 'Name', width: 140, sortable: true, dataIndex: 'name'},
        {header: 'Zip', width: 35, sortable: true, dataIndex: 'zip'},
        {header: 'City', width: 90, sortable: true, dataIndex: 'city'},
        {header: 'Phone', width: 50, sortable: true, dataIndex: 'phone'},
    ],
    viewConfig: { forceFit: true, },
    // only one toolbar can be passed inline
    tbar: myActionButtonsTopToolbar, // this one has add/delete/refresh buttons
    bbar: myInfoBottomToolbar,
});


myWindow.show();
myDataStore.load(); 
myAlphaTbar = new Ext.Toolbar({ 
    renderTo: myListGrid.tbar, // that one line did the job!! 
    items: myAlphaTbarItems, // use formerly created buttons
}); 
myListGrid.syncSize(); // don't do that and the toolbar may not appear!


Para despresionar los botosnes

for(var i = 65; i < 91; i++) { // unpress the pressed alphaTbarItem toggle Button
    var myChar = String.fromCharCode(i); // get the char (from A to Z) 
    var cmp = Ext.getCmp('alphaTbarItem' + myChar); // get the component under that name
    if (cmp.pressed) cmp.toggle(); // if it's pressed, toggles (unpress) it! 
}


