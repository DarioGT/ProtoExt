SandBox 

PAra el manejo de prototipos onLine es necesario poder manejar diferentes modelos creados dinamicamente, 

El sandBox puede ser una configuracion de servidor q permita diferentes ambientes, pero sigue existiendo 
el problema de la creacion dinamica de modelos y su ejecucion 


Modelos dinamicos 

Los modelos dinamicos pueden ser de tres tipos,   
    - key-Value,  ( http://en.wikipedia.org/wiki/Entity-attribute-value_model )
                  ( http://nativexmldatabase.com/2011/01/21/namevalue-pairs-a-pretty-bad-idea-in-xml-as-in-relational/ )
    - jsonField,  ( http://martinfowler.com/eaaCatalog/serializedLOB.html )
    - dynamicModel
    
Key-value : es una extencion del concpeto de UDP, las busquedas son complicadas y la carga puede ser lenta,
este modelo se justifica cuando el contenido de los campos es grande, por ejemplo templates de pantalla o reporte 

 
jsonField : puede ser el mas flexible de todos, el campo tiene la definicion de los otros campos q sera leido y adicionado 
a la fila de retorno, la busqueda va sobre el campo completo, no permite criterios especificos,  los nombres de los campos 
no pueden ser usados como criterios de busqueda ( son siempre positivos )

dynamicModel : usando django-south se puede manejar la creacion dinamica de modelos, django maneja la funcion type() 
para crear clases dynamicamente,  es complejo de implementar y ademas requiere continuos cambios en la db, lo q puede 
ser lento,  en produccion seria la mejor opcion.


DEfinicion 

La definicion se puede hacer usando el diccionario, pero la lectura relacional puede ser lenta, ademas seria bueno 
tener un nivel de publicacion para poder hacer los cambios q se requieran,  este proceso podria ser en ambos sentidos,
es decir a partir de una vista publicada, se podria obteer la definicion relacional para edicion. 

La edicion podria ser directamente en la meta, evitando el manejo relacional, en este caso la publicacion seria simplemente 
un atributo ( o una copia si se requiere )

DEfinicion 

conceptName 
conceptDefinition    
usr
nodoAuth    ( jerarquia de autorizacion ) 
version     ( manejar el history ) 


--------

Las tablas generadas por el prototipador se crean en unico modelo ( tabla administrada por Django ), 

Esta tabla fisica contiene un 
    id,
    tableName 
    campo json con las ocurrencias de todos los campos
    info de seguridad 

La tabla manejar un QueryManager q permita hacer una busqueda dentro del campo json para poder encadenar los maestros detalle. 

La definicion de la meta si encuentra un jsonField toma todas las UDP directamente. 

Queda una tabla con la definicion basica y la generacion de las pcl, 

1. Query /  Ok,  
	el Query se puede hacer por llave sobre la estructura JSon 
	y  textSearch se hace sobre el texto json ( si el criterio contiene los campos,  todos los reg son validos :\)


2.  Definicion 

    Las entidades definidas en el dict son protoEntidades definidas sobre una unica tabla  ( protoTable )
	
    Las definiciones de prototype se compilan directamtne como "pci"  creadas como  vistas  de la tabla base 

    Las protoPropiedades se definen con el prefijo  "info__" para indicar un pseudoCampo json

	protoTable :
		protoEntity   
		protoFields  ( info )
		*AuthFields

	prototype.protoTable.[protoEntity]

    El campo protoEntity como valor por defecfto la protoEntidad y 
    ademas tiene un filtro de base  baseFilter = { 'property' : protoEntity, 'filterStmt' : [protoEntity] }

    Esto permitira q en la misma tabla se almacenen diferentes entidades 

    Ademas en
        protoDefinition ( ya existente )

        customDefinition : maneja las definiciones por grupo, 
            si el usuario es administrador de grupo ( por ahora solo asi ) cambiara las opciones a nivel de grupo 
            si no solo a nivel de usuario 

        Cuando se guarde en customDefinition la llave es code - ownGroup 

    NO ------------------------------------
        se permite 
            protoDefinitionGrp   ( por grupo, almacena las definiciones de las tablas )
            protoDefinitionUsr   ( por usuario, el menu y las definicione personalizadas  )

        para esto se agregan campos para manejar la pertencencia
            groupOwner 
            userOwner 

        y una funcion para indetificar la pertencia 
            ownerType   'S'  System 
                        'G'  Group

2. Menu  

    Solo se crea una vista de cada "protoEntidad", pero se permitira un saveAs para cambiar 
    el nombre de la vista respetando el modelo de base 

    EL menu se carga en tandas 
    1. carga el menu estandar de la app, 
    2. EXiste una tabla proto.ProtoViews q contiene el valor por para generar un lib.CustonDefinition 
    2. -- NO: carga el menu por hiierarchiNode con las opciones compiladas  para el grupo  ( protoDefinition ownereType :'G')

    Prototypes :
        protoEntity     --
        protoView       --> apunta a la definicion 
        *AuthFields


    Las definiciones existen siempre en la tabla de protoDefinicion, 
    pero se crean unas vistas por modelo para el grupo ( auth )

    Hay tres niveles de menu, 

        el menu generado a partir de las app, 
        el menu guardado en protoDefinition 
        el menu de usuarios 

    Solo el administrador podra cambiar el menu en protodefinition, 
    borra el menu general y regresa al menu generado de la app  
    
    Un admin de grupo solo borra su menu y regresa al menu general 

    Desde el prototipador se genera el menu de grupo a partir del dominio 
    basado en las vistas generadas por el usuario., 

    Las creacion de la vista generara la protoDefinition, 
*** por ahora generar una unica vista 

3.  Filtros para los zooms 


----------------------

    obj = Person.objects.create(name = "Bill")
    obj.info = {'sex': 'male','address': {'country', 'Canada',}}
    obj.save()
    Person.objects.filter(info__address__country = 'Canada')
    >>> [Person: "Bill"]

obj = model.objects.create(info = {'sex': 'male','address': {'country' :'Canada',}})