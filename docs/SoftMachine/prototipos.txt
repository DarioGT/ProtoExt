SandBox 

PAra el manejo de prototipos onLine es necesario poder manejar diferentes modelos creados dinamicamente, 

El sandBox puede ser una configuracion de servidor q permita diferentes ambientes, pero sigue existiendo 
el problema de la creacion dinamica de modelos y su ejecucion 


Modelos dinamicos 

Los modelos dinamicos pueden ser de tres tipos,   
    - key-Value,  ( http://en.wikipedia.org/wiki/Entity-attribute-value_model )
                  ( http://nativexmldatabase.com/2011/01/21/namevalue-pairs-a-pretty-bad-idea-in-xml-as-in-relational/ )
    - jsonField,  ( http://martinfowler.com/eaaCatalog/serializedLOB.html )
    - dynamicModel
    
Key-value : es una extencion del concpeto de UDP, las busquedas son complicadas y la carga puede ser lenta,
este modelo se justifica cuando el contenido de los campos es grande, por ejemplo templates de pantalla o reporte 

 
jsonField : puede ser el mas flexible de todos, el campo tiene la definicion de los otros campos q sera leido y adicionado 
a la fila de retorno, la busqueda va sobre el campo completo, no permite criterios especificos,  los nombres de los campos 
no pueden ser usados como criterios de busqueda ( son siempre positivos )

dynamicModel : usando django-south se puede manejar la creacion dinamica de modelos, django maneja la funcion type() 
para crear clases dynamicamente,  es complejo de implementar y ademas requiere continuos cambios en la db, lo q puede 
ser lento,  en produccion seria la mejor opcion.


DEfinicion 

La definicion se puede hacer usando el diccionario, pero la lectura relacional puede ser lenta, ademas seria bueno 
tener un nivel de publicacion para poder hacer los cambios q se requieran,  este proceso podria ser en ambos sentidos,
es decir a partir de una vista publicada, se podria obteer la definicion relacional para edicion. 

La edicion podria ser directamente en la meta, evitando el manejo relacional, en este caso la publicacion seria simplemente 
un atributo ( o una copia si se requiere )

DEfinicion 

conceptName 
conceptDefinition    
usr
nodoAuth    ( jerarquia de autorizacion ) 
version     ( manejar el history ) 


--------

Las tablas generadas por el prototipador se crean en unico modelo ( tabla administrada por Django ), 

Esta tabla fisica contiene un 
    id,
    tableName 
    campo json con las ocurrencias de todos los campos
    info de seguridad 

La tabla manejar un QueryManager q permita hacer una busqueda dentro del campo json para poder encadenar los maestros detalle. 

La definicion de la meta si encuentra un jsonField toma todas las UDP directamente. 

Queda una tabla con la definicion basica y la generacion de las pcl, 

1. Query /  Ok,  
	el Query se puede hacer por llave sobre la estructura JSon 
	y  textSearch se hace sobre el texto json ( si el criterio contiene los campos,  todos los reg son validos :\)


2.  Definicion 

    Las entidades definidas en el dict son protoEntidades definidas sobre una unica tabla  ( protoTable )
	
    Las definiciones de prototype se compilan directamtne como "pci"  creadas como  vistas  de la tabla base 

    Las protoPropiedades se definen con el prefijo  "info__" para indicar un pseudoCampo json

	protoTable :
		protoEntity
		protoField  ( info )
		*AuthFields

	prototype.protoTable.[protoEntity]

    Ademas en
        protoDefinition ( ya existente )

    se permite 
        protoDefinitionGrp   ( por grupo, almacena las definiciones de las tablas )
        protoDefinitionUsr   ( por usuario, el menu y las definicione personalizadas  )

    para esto se agregan campos para manejar la pertencenci 
        groupOwner 
        userOwner 

    y una funcion para indetificar la pertencia 
        ownerType   'S'  System 
                    'G'  Group
                    'U'  User 

2. Menu  

    Por el momento solo se crea una vista de cada "protoEntidad"

    EL menu se carga en tandas 
    1. carga el menu estandar de la app, 
    2. carga el menu por hiierarchiNode con las opciones compiladas  para el grupo  ( protoDefinition ownereType :'G')



----------------------

    obj = Person.objects.create(name = "Bill")
    obj.info = {'sex': 'male','address': {'country', 'Canada',}}
    obj.save()
    Person.objects.filter(info__address__country = 'Canada')
    >>> [Person: "Bill"]

obj = model.objects.create(info = {'sex': 'male','address': {'country' :'Canada',}})